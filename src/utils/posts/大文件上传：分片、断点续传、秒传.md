
## 核心流程

```
计算 hash → 检查秒传 → 分片 → 并发上传 → 失败重试 → 合并
```

## 快速开始

### 安装依赖

```bash
npm install spark-md5
```

### 自定义 Hook: useFileUploader

```javascript
// composables/useFileUploader.js
import { ref } from 'vue';
import SparkMD5 from 'spark-md5';

export function useFileUploader(endpoint = '/api/upload') {
  const file = ref(null);
  const progress = ref(0);
  const uploading = ref(false);
  const message = ref('');
  const error = ref(false);

  // 计算文件 hash
  const computeHash = async (fileData) => {
    return new Promise((resolve) => {
      const spark = new SparkMD5.ArrayBuffer();
      const reader = new FileReader();
      let offset = 0;
      const chunkSize = 2097152; // 2MB

      const load = () => {
        const end = Math.min(offset + chunkSize, fileData.size);
        reader.readAsArrayBuffer(fileData.slice(offset, end));
      };

      reader.onload = (e) => {
        spark.append(e.target.result);
        offset += chunkSize;
        if (offset < fileData.size) {
          load();
        } else {
          resolve(spark.end());
        }
      };

      load();
    });
  };

  // 分片
  const sliceFile = (fileData, chunkSize = 5 * 1024 * 1024) => {
    const chunks = [];
    let offset = 0;

    while (offset < fileData.size) {
      const end = Math.min(offset + chunkSize, fileData.size);
      chunks.push({
        index: chunks.length,
        blob: fileData.slice(offset, end)
      });
      offset = end;
    }

    return chunks;
  };

  // 检查秒传
  const checkSecondTransmission = async (hash, filename, size) => {
    const res = await fetch(`${endpoint}/check`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hash, filename, size })
    });

    const data = await res.json();
    return data.exist ? 'exist' : (data.uploadedChunks || []);
  };

  // 上传单个分片（带重试）
  const uploadChunk = async (chunk, hash, filename, retries = 0) => {
    const formData = new FormData();
    formData.append('chunk', chunk.blob);
    formData.append('hash', hash);
    formData.append('index', chunk.index);
    formData.append('filename', filename);

    try {
      return await fetch(endpoint, {
        method: 'POST',
        body: formData
      });
    } catch (err) {
      if (retries < 3) {
        const delay = Math.pow(2, retries) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return uploadChunk(chunk, hash, filename, retries + 1);
      }
      throw err;
    }
  };

  // 并发上传
  const uploadConcurrent = async (chunks, hash, filename, concurrency = 3) => {
    for (let i = 0; i < chunks.length; i += concurrency) {
      const batch = chunks.slice(i, i + concurrency);
      await Promise.all(
        batch.map((chunk, idx) =>
          uploadChunk(chunk, hash, filename).then(() => {
            const currentProgress = ((i + idx + 1) / chunks.length) * 100;
            progress.value = currentProgress;
          })
        )
      );
    }
  };

  // 合并分片
  const mergeChunks = async (hash, filename, total) => {
    return fetch(`${endpoint}/merge`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hash, filename, total })
    }).then(res => res.json());
  };

  // 完整上传流程
  const upload = async (fileData) => {
    if (!fileData) return;

    uploading.value = true;
    message.value = '';
    error.value = false;
    progress.value = 0;

    try {
      // 1. 计算 hash
      const hash = await computeHash(fileData);

      // 2. 检查秒传
      const checkResult = await checkSecondTransmission(
        hash,
        fileData.name,
        fileData.size
      );

      if (checkResult === 'exist') {
        progress.value = 100;
        message.value = '✓ 秒传成功！';
        return { success: true, secondTransmission: true };
      }

      // 3. 分片
      const chunks = sliceFile(fileData);

      // 4. 并发上传
      await uploadConcurrent(chunks, hash, fileData.name);

      // 5. 合并
      const result = await mergeChunks(hash, fileData.name, chunks.length);
      message.value = '✓ 上传成功！';
      return { success: true, ...result };
    } catch (err) {
      message.value = '❌ 上传失败: ' + err.message;
      error.value = true;
      console.error(err);
    } finally {
      uploading.value = false;
    }
  };

  const handleFile = (fileData) => {
    file.value = fileData;
  };

  const reset = () => {
    file.value = null;
    progress.value = 0;
    uploading.value = false;
    message.value = '';
    error.value = false;
  };

  return {
    file,
    progress,
    uploading,
    message,
    error,
    upload,
    handleFile,
    reset
  };
}
```

## Vue 3 使用

```vue
<template>
  <div class="uploader">
    <input type="file" @change="e => handleFile(e.target.files?.[0])" />
    
    <div v-if="file">
      <p>{{ file.name }} - {{ (file.size / 1024 / 1024).toFixed(2) }}MB</p>
      <div class="progress-bar">
        <div :style="{ width: progress + '%' }"></div>
      </div>
      <p>{{ progress.toFixed(0) }}%</p>
      
      <button @click="() => upload(file)" :disabled="uploading">
        {{ uploading ? '上传中...' : '开始上传' }}
      </button>
      <button v-if="uploading" @click="reset" class="cancel-btn">取消</button>
      
      <p v-if="message" :class="{ error }">{{ message }}</p>
    </div>
  </div>
</template>

<script setup>
import { useFileUploader } from '@/composables/useFileUploader';

const {
  file,
  progress,
  uploading,
  message,
  error,
  upload,
  handleFile,
  reset
} = useFileUploader('/api/upload');
</script>

<style scoped>
.uploader {
  padding: 20px;
  max-width: 400px;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: #e0e0e0;
  border-radius: 3px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-bar > div {
  height: 100%;
  background: #0066cc;
  transition: width 0.3s;
}

button {
  margin: 10px 5px 10px 0;
  padding: 8px 16px;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover:not(:disabled) {
  background: #0052a3;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.cancel-btn {
  background: #cc0000;
}

.error {
  color: #cc0000;
}
</style>
```

## 后端（Node.js/Express）

```javascript
const express = require('express');
const multer = require('multer');
const fs = require('fs-extra');
const path = require('path');

const router = express.Router();
const tempDir = './temp';
const uploadDir = './uploads';

fs.ensureDirSync(tempDir);
fs.ensureDirSync(uploadDir);

// 检查秒传
router.post('/check', async (req, res) => {
  const { hash, filename } = req.body;
  const filePath = path.join(uploadDir, `${hash}_${filename}`);
  
  if (fs.existsSync(filePath)) {
    return res.json({ exist: true });
  }
  
  res.json({ exist: false });
});

// 上传分片
router.post('/', multer({ dest: tempDir }).single('chunk'), (req, res) => {
  const { hash, index, filename } = req.body;
  const chunkPath = path.join(tempDir, `${hash}_${index}`);
  
  fs.renameSync(req.file.path, chunkPath);
  res.json({ success: true });
});

// 合并分片
router.post('/merge', async (req, res) => {
  const { hash, filename, total } = req.body;
  const filePath = path.join(uploadDir, `${hash}_${filename}`);
  const writeStream = fs.createWriteStream(filePath);

  for (let i = 0; i < total; i++) {
    const chunkPath = path.join(tempDir, `${hash}_${i}`);
    const data = await fs.readFile(chunkPath);
    writeStream.write(data);
    fs.removeSync(chunkPath);
  }

  writeStream.end();
  
  res.json({ success: true, url: `/uploads/${hash}_${filename}` });
});

module.exports = router;
```

## 关键参数

| 参数 | 推荐值 | 说明 |
|------|--------|------|
| 分片大小 | 5-20MB | 移动网络 5MB，PC 端 10-20MB |
| 并发数 | 3-6 | 平衡速度与服务器压力 |
| 重试次数 | 3 | 失败重试，指数退避 1s → 2s → 4s |
| 重试延迟 | 2^n 秒 | 指数退避策略 |

## 工作流程

```
用户选择文件
    ↓
计算 MD5 hash
    ↓
向服务器查询：文件是否存在？
    ├─ 存在 → 秒传成功 ✓
    └─ 不存在 → 继续
    ↓
将文件分片 (5-20MB/片)
    ↓
最多 3-6 个分片并发上传
    ├─ 成功 → 继续下个分片
    └─ 失败 → 指数退避重试
    ↓
所有分片上传完成
    ↓
向服务器发送合并请求
    ↓
服务器按顺序合并分片
    ↓
上传完成 ✓
```

## 进度计算

```javascript
// 进度 = 已上传分片数 / 总分片数
const progress = (uploadedCount / totalChunks) * 100;

// 速度 = 已上传字节 / 耗时
const speed = uploadedBytes / elapsedSeconds;

// 剩余时间 = 剩余字节 / 速度
const remaining = (totalSize - uploadedBytes) / speed;
```

## 常见问题

**Q: 如何恢复断点上传？**  
A: 重新调用 `upload()`，检查秒传时返回已上传分片列表，跳过已上传分片继续上传。

**Q: 分片大小如何选择？**  
A: 5MB 安全但慢，20MB 快但可能失败。根据网络选择，移动 5-10MB，PC 10-20MB。

**Q: 如何避免上传重复文件？**  
A: 通过 hash 值检查秒传，服务器保存文件 hash，相同 hash 直接返回成功。

---

*最后更新：2026 年 1 月*